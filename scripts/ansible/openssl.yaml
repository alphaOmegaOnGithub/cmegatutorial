## Uninstall docker
for pkg in docker.io docker-doc docker-compose docker-compose-v2 podman-docker containerd runc; do sudo apt-get remove $pkg; done
## install docker
# Add Docker's official GPG key:
sudo apt-get update
sudo apt-get install ca-certificates curl
sudo install -m 0755 -d /etc/apt/keyrings
sudo curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc
sudo chmod a+r /etc/apt/keyrings/docker.asc

### To install the latest version, run:
 sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin

# Add the repository to Apt sources:
echo \
  "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \
  $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | \
  sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
sudo apt-get update

### ===================================================

 sudo apt-get install openssl version -a
   openssl version
   openssl version -a
   sudo apt install apache2-utils -y
   mkdir -p  ~/registry/auth
   cd        ~/registry/auth
   htpasswd -c -B -b passwd-file devops P@ssWord32!
   mkdir ~/registry/certs
   cd ~/registry/certs

### ===================================================
   sudo mkdir /certs
   sudo openssl req \
  -newkey rsa:4096 -nodes -sha256 -keyout /certs/registry.local.key \
  -addext "subjectAltName = DNS:registry.local, DNS:registry, DNS:vagabuntu02" \
#  -addext "subjectAltName = DNS2:registry" \
#  -addext "subjectAltName = DNS3:vvagabuntu02" \
  -x509 -days 365 -out certs/registry.local.crt
### =================================================== 
   openssl genrsa 2048 > domain.key
   chmod 400 domain.key
   cd ~/registry/
   docker run -d \
  --restart=always \
  --name private-registry \
  -v `pwd`/auth:/auth \
  -v `pwd`/certs:/certs \
  #-e REGISTRY_HTTP_SECRET=secret
  -e REGISTRY_AUTH=htpasswd \
  -e REGISTRY_AUTH_HTPASSWD_REALM="Registry Realm" \
  -e REGISTRY_AUTH_HTPASSWD_PATH=/auth/passwd-file \
  -e REGISTRY_HTTP_ADDR=0.0.0.0:443 \
  -e REGISTRY_HTTP_TLS_CERTIFICATE=/certs/domain.crt \
  -e REGISTRY_HTTP_TLS_KEY=/certs/domain.key \
  -p 443:443 \
  registry:2
### minio extension file minio.ext

###  CA key pair andcertificate chain    
### old
 openssl req -x509 -sha256 -days 1825 -newkey rsa:2048 -keyout rootCA.key -out rootCA.crt   openssl x509 -req -CA rootCA.crt -CAkey rootCA.key -in minio.csr -out minio.crt -days 365 -CAcreateserial -extfile minio.ext
 ### 
   openssl req -new -newkey rsa:2048 -nodes -keyout minio.key -out minio.csr
   openssl req -text -in minio.csr  -noout -verify
###    
   openssl x509 -signkey domain.key -in minio.csr  -req -days 365 -out minio.crt
   openssl x509 -signkey minio.key  -in minio.csr  -req -days 365 -out minio.crt
###
   openssl req -newkey rsa:2048 -nodes -keyout minio.key -out minio.csr
   openssl x509 -text -noout -in minio.crt
   openssl x509 -in minio.crt -outform der -out minio.der
###
   88  openssl pkcs12 -inkey domain.key -in minio.crt -export -out minio.pfx
   89  openssl pkcs12 -inkey minio.key -in minio.crt -export -out minio.pfx
   90  history | grep openssl

### ==============================================================================

## Generate the Certificate Authority (CA) Private Key over elliptical curves 
 openssl ecparam -name prime256v1 -genkey -noout -out ca.key
### Generate the Certificate Authority Certificate
 openssl req -new -x509 -sha256 -key ca.key -out ca.crt
### Generate your server certificate
openssl ecparam -name prime256v1 -genkey -noout -out server.key
### Generate the server certificate signing request
openssl req -new -sha256 -key server.key -out server.csr
### Generate the server certificate - optional) You can create a file named server-extensions.txt if you want to provide specific extensions for your certificate.
extendedKeyUsage=serverAuth   # check server authentication key usage (oid : 1.3.6.1.5.5.7.3.1):
openssl x509 -req -in server.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out server.crt -days 1000 -sha256 -extfile server-extensions.txt
### Generate server certificate pfx  - If you want to combine the private key and public key together and have a single pfx file you can use the following command:
openssl pkcs12 -export -out server.pfx -inkey server.key -in server.crt

### Generate your client(s) certificate(s)
openssl ecparam -name prime256v1 -genkey -noout -out client1.key
### Generate the client certificate signing request
openssl req -new -sha256 -key client1.key -out client1.csr
### Generate the client certificate - (optional) You can create a file named client-extensions.txt if you want to provide specific extensions for your certificate. In this tutorial I will provide client authentication key usage (oid : 1.3.6.1.5.5.7.3.2) :

## client-extensions.txt content: extendedKeyUsage=clientAuth
openssl x509 -req -in client1.csr -CA ca.crt -CAkey ca.key -CAcreateserial -out client1.crt -days 1000 -sha256 -extfile client-extensions.txt

### Generate client certificate pfx
openssl pkcs12 -export -out client1.pfx -inkey client1.key -in client1.crt

## Using Docker official docs 
### Create a CA, server and client keys with OpenSSL 

1: openssl genrsa -aes256 -out ca-key.pem 4096
### Create a CA, server and client keys with OpenSSL 
2: openssl req -new -x509 -days 365 -key ca-key.pem -sha256 -out ca.pem 

### Now that you have a CA, you can create a server key and certificate signing request (CSR). 
### Make sure that "Common Name" matches the hostname you use to connect to Docker:

openssl genrsa -out server-key.pem 4096

openssl req -subj "/CN=$HOST" -sha256 -new -key server-key.pem -out server.csr
openssl req -subj "/CN=registry.local" -sha256 -new -key registry-key.pem -out registry.csr

### Next, we're going to sign the public key with our CA: 
### Since TLS connections can be made through IP address as well as DNS name, 
### the IP addresses need to be specified when creating the certificate. 
### For example, to allow connections using 10.10.10.20 and 127.0.0.1:
echo subjectAltName = DNS:registry.local,DSN:registry,DNS:vagabuntu02,DNS:vm02,IP:10.10.10.20,IP:127.0.0.1 >> extfile.cnf

### Set the Docker daemon key's extended usage attributes to be used only for server authentication:
echo extendedKeyUsage = serverAuth >> extfile.cnf

### Now, generate the signed certificate:
 openssl x509 -req -days 365 -sha256 -in registry.csr -CA ca.pem -CAkey ca-key.pem -CAcreateserial -out registry-cert.pem -extfile extfile.cnf

### For client authentication, create a client key and certificate signing request:
openssl genrsa -out client-key.pem 4096

### create a client cert request 
openssl req -subj '/CN=client' -new -key key.pem -out client.csr

### To make the key suitable for client authentication, create a new extensions config file:
 echo extendedKeyUsage = clientAuth > extfile-client.cnf
 
### Now, generate the signed certificate:
openssl x509 -req -days 365 -sha256 -in client.csr -CA ca.pem -CAkey ca-key.pem \
  -CAcreateserial -out client-cert.pem -extfile extfile-client.cnf
  
### After generating cert.pem and server-cert.pem you can safely remove the two certificate signing requests and extensions config files: 
###  rm -v client.csr server.csr extfile.cnf extfile-client.cnf

### With a default umask of 022, your secret keys are world-readable and writable for you and your group.
### To protect your keys from accidental damage, remove their write permissions. To make them only readable by you, change file modes as follows:

 chmod -v 0400 ca-key.pem client-key.pem registry-key.pem

### Now you can make the Docker daemon only accept connections from clients providing a certificate trusted by your CA:

dockerd \
    --tlsverify \
    --tlscacert=/home/cmadmin/.docker/ca.pem \
    --tlscert=/home/cmadmin/.docker/cert.pem \
    --tlskey=/home/cmadmin/.docker/key.pem \
    -H=0.0.0.0:2376

### To connect to Docker and validate its certificate, provide your client keys, certificates and trusted CA:
 docker --tlsverify \
    --tlscacert=ca.pem \
    --tlscert=cert.pem \
    --tlskey=key.pem \
    -H=registry:2376 version